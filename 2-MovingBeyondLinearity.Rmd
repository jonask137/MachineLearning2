---
output: html_document
editor_options: 
  chunk_output_type: console
---

```{r}
library(dplyr)
```


# Moving Beyond Linearity

Literature:

- Moving Beyond Linearity (ISL CH7)


Recall that complexity = also means lower interpretibility. This subject extents the linear models with the following:

1. Polunomial Regression - where polynomials of the variables are added.
2. Step Functions - where the x range is cut into k distinct regions to produce a qualitative variable. Hence also the name, piecewise constant function.
3. Regression Splines - a combination / extensions of number one and two. Where polynomials functions are applied in specified regions of an X range.
4. Smoothing Splines - Similar to the one above, but slightly different in the fitting process.
5. Local Regression - Similar to regression splines, but these are able to overlap.
6. Generalized Additive Models - allows to extent the model with several predictors.

## Models Beyond Linearity

Notice that all approaches despite GAM are extensions of simple linear regression, as it only takes on one predictor variable.

### Polynomial Regression

Can be defined by the following

\begin{equation}
y_{i\ }=\ \beta_0+\beta_1x_i+\beta_2x_i^2+...+\ \beta_dx_i^d\ +\ \epsilon_i
(\#eq:PolynomialRegression)
\end{equation}

Rules of thumb:

+ We don't take on more than 3 or 4 degrees of d, as that yields strange lines

Note that we can still use standard errors for coefficient estimates.


#### Beta coefficients and variance

Each beta coefficient has its own variance (just as in linear regression).

It can be defined by a matrix of j dimensions, e.g., if you have 5 betas (including beta 0) we can construct the correlation matrix.

Covariance matrix can be identified by $\hat{C}$.

Generally we get point estimates, but it is also interesting to show the confidence intervals (using 2 standard errors).

Notice, that we cant really interprete beta coefficients as we do with linear regression, hence we dont have the same ability to do inference as the coefficients are missleading.

#### Application procedure

1. Use `lm()` or `glm()`
2. Use DV~poly(IV,degree)
3. Perform CV with `cv.glment()` / aonva F-test to select degree
    + This is basically either visually selecting the degrees that are the best using CV or using an ANOVA to assess if the MSE are significantly different from each other, hence an ANOVA test. Regarding ANOVA, if there stop being significance, then significant changes, e.g., in a poly 8, where the previous polynomials was not significant, then we can also disregard the 8'th polynomial.
4. Fit the selected model
5. Look at `coef(summary(fit))`
6. Plot data and predictions with `predict()`
7. Check residuals
8. Interpret

The lecture shows exercise number 6 in chapter 7.


### Step Functions

This is literally just fitting a constant in different bins, see example on page 269. This is also called discretizing x. Thus it is not polynoomial, but it is non linear.

It is often applied when we see, e.g., five year age bins, e.g., a 20-25 year old is expected to earn so and so much etc. But we can only really use it, when there are natural cuts, hence one must be considerate using the model.

__Major disadvantage:__ If there are no natural breakpoints, then the model is likely to miss variance and also generalize too much.

Remember, that the steps reflect the average increase in Y for each step. Hence the first bin (range) is defined by $\beta_0$, and can be regarded as the average of that range of x. Thus each coefficient of the ranges of x is to be understood as the average increase of response.

In other words, $\beta_0$ is the reference level, where the following cuts reflect the average increase or decrease hereon.

Note that we can still use standard errors for coefficient estimates.

### Regression Splines



#### Piecewise Polynomials

This is basically polynomial regression, where the coefficients apply to specified ranges of X. The points where the coefficients changes are called ___knots___. Hence a cubic function will look like the following.

Notice, that a piecewise polynomial function with no knots, is merely a standard polynomial function.

\begin{equation}
y_{i\ }=\ \beta_0+\beta_1x_i+\beta_2x_i^2+\ \beta_3x_i^3\ +\ \epsilon_i
(\#eq:PiecewisePolynomials)
\end{equation}

Where it can be extended to be written for each range.

The coefficients can then be written with: $\beta_{01},\beta_{11},\beta_{21}$ etc. and for the second set: $\beta_{02},\beta_{12},\beta_{22}$ 

And for each of the betas in all of the cuts, you add one degree of freedom.

Rule of thumb:

+ The more knots, the more complex = the more variance capture and noise trailed, hence low model bias but large model variance.

```{r,echo=FALSE,fig.cap="Piecewise Polynomials"}
knitr::include_graphics(rep("Images/Piecewise regression.png"))
```


#### Constraints and Splines

**It is a spline when the piecewise polynomials have been imposed with restrictions for continouity and derivatives, so the knot don't break or so to say, hence the knot will not be visible.**

Figure 7.3 show how the splines look, as the top left window tell, the jump is rather odd. Hence, we can force the fit to be continuous, by imposing a constraint.

Notice, that it is a piecewise polynomial regression, when you merely fit polynomials onto bins of data. If you want to have the ends tied together, you impose contraints and thus created a spline.

We can further constrain the model, with adding derivatives of the functions, hence the first derivative and the second derivative (where it in this instance created linear splines, that is because we have added $d-1$ i.e. 2 derivatives, if the function was to the power of 4, then we should have imposed 3 derivatives to achieve linearity in the splines.)

Hence, the _linear spline_ can be defined by: It is piecewise splines of degree-d polynomials, with continuity in derivatives up to degree $d-1$ at each knot.

Hence we have the following constraints:

1. Continuity
2. Derivatives

#### Choosing the number and location of the Knots

Choosing amount of knots? One may ask themself, how many degrees of freedom do you want to include in the model?

Amount of knots is therefore corresponding to amount of degrees of freedom.

We can let software estimate the best amount and the best locations. Here one can use:

1. In-sample performance
2. Out-of-sample performance, e.g. with CV, perhaps extent to K folds with K tests, to ensure, that each variable has been held out once.

This can be followed by visualizing the MSE for the different simulations with different amount of knots.

#### Degrees of freedom

You count the amount of coefficients in the piecewise polynomial. Then you deduct df as you impose restrictions.

e.g. with one knot, you impose conituity, then you deduct one 1 df. for each derivative that we impose we can subtract one df.

Therefore the example above: 8 df in the beginning less 1 for the cut and two for the two derivatives. Hence, we end up with 5 df.


#### Comparison with Polynomial Regression

With regression splines we are able to introduce knots that account for variance as it slightly resets the model in each section, hence we can fit the model to the data without having to impose as much complexity as we would in normal polynomial regression.

Hence one often observes that regression splines have more stability than polynomial regression.



### Smoothing Splines

In prediction this is slightly better than basic functions and natural splines.

This is basically attempting to find a model that captures the variance by a smoothing line. Doing so, we fit a very flexible model and impose restrictions upon this, to achieve a shrunken model, just as with Lasso and Ridge Regression. Thus, the smoothing (imposing restrictions) deals with overfitting.

Also as we havee discovered previously, that degrees of freedom is equivilant with amount of knots, e.g., in polynomial splines, then three knots in a cubic function leads to 6 degrees of freedom, hence an smooth spline with df = 6.8 can be said to approximately have 3 knots, but we will never really know.

This can be defined as a cubic spline with knot at every unique value of $x_i$

Hence we have the following model:

\begin{equation}
RSS=\sum_{i=1}^n\left(y_i-g\left(x_i\right)\right)^{^2}+\lambda\int g''\left(t\right)^{^2}dt
(\#eq:SmoothingSplines)
\end{equation}

_i.e. Loss + Penalty_

*Recall that the penalty controls the curvature of the function*

Where:

+ We define model g(x)
+ $(y_i-g(x_i))^{^2}$ = the loss, meaning the difference between the fitted model and the actual y's
+ $\lambda$ = the tuning parameter, hence the restriction that we want to impose. If lambda is low, then much flexibility, if lambda is high, then low flexibility. Hence, controls the bias variance tradeoff.
+ $\int g''\left(t\right)^{^2}dt$ = a measure of how much $g'(x)$ changes oer time. Hence, the higher we set $\lambda$ the more imposed restrictions, meaning the smoother the model, as lambda gets closer to infinity, the model becomes linear.

#### Choosing optimal tuning parameter

The analytic LOOCV can be calculated, the procedure appears to be the same as for lasso and ridge regression. The book (page 279) describes this a bit in details. However it says that software is able to do this.

Basically what is done, is LOOCV and simulating different tuning parameters to assess what model that performs the best.

Notice, that in R we are not working with $\lambda$, but we can control the df associated with lambda. Or we can just let the model choose.

With this, degrees of freedom is not the same as we are used to. This creates sparsity as we know from regularization.

*We are not expected to explain this, but we should be able to interpret the results*


### Local Regression

This i basically fitting a linear regression to each x, where s observations are included in the fitting procedure. Thus, one creates several fits, that are based on the observations weighted, where observations close to $x_0$ (the center of the regression) are given the highest weight and then the weight is gradually decreasing.

This is often really good when you have outliers, as you define how big a neighborhood you want to evaluate (also called the span, e.g. span of 0.5 = 50% of the observations).

This can be visualized with:

```{r,echo=FALSE,fig.cap="Local regression"}
knitr::include_graphics(rep("Images/Local Regression.png"))
```

Doing local regression has the following procedure (algorithm)

1. Gather the fraction $s = k/n$ of training points whose $x_i$ are closest to $x_0$.
2. Assign a weight $K_{i0} = K(x_i, x_0)$ to each point in this neighborhood, so that the point furthest from x0 has weight zero, and the closest has the highest weight. All but these k nearest neighbors get weight zero.
3. Fit a weighted least squares regression of the $y_i$ on the $x_i$ using the aforementioned weights, by finding $\hat\beta_0$ and $\hat\beta_1$ that minimize

\begin{equation}
\sum_{i=1}^nK_{i0}\left(y_i-\beta_0-\beta_1x_i\right)^{^2}
(\#eq:LocalRegression)
\end{equation}

4. The fitted value at $x_0$ is given by $\hat{f}(x_0)=\hat\beta_0+\hat\beta_1x_0$


Where we see how the model is 

### Generalized Additive Models

This can naturally both be applied in regression and classification problems, futher elaborated in the following.

It is called generalized, as the dependent variable can be both continuous (e.g. Gaussian) and categorical (e.g., binomial, Poisson, or other distributions) distributed

Additive = the model is adding different polynomials of the IDV toghether. Notice, as the model is additive, it does not account for interactions, then you have to specify the interactions.

Thus GAM is merely an approach to make a model, where we include the posibility of having non linear components. Hence we include more complex model (with the ability to trail the observations more than linear models).

But the advantage of linear regressions, are that we are able to quickly deduct the effects the variables. Although we dont always have a linear relationship, hence you can be forced to choose a more complex model. (see the R file "GAMs with discussion R").

We have previously worked with non parametric models (e.g., KNN regression). GAM is in between linear regression and non parametric models.

That is the beuty of GAMs, as we preserve the ability of having transparancy in the model, despite it coming at a cost of worse prediction power than neural networks, but at such complex models, you are not able to deduct how the variables are interrelated, you can only say which are important and which are not.


***What are the assumptions for GAMS??***

+ 


#### GAM for regression problems

Now we move beyond being constrained to only one predictor variable, hence GAM can be seen more as an extension of multiple linear regression. Hence GAM is a combination of different functions, where they are each fitted while holding the other variables fixed. GAM can consist of any different non-linear model, e.g., we can just as well use local regression, polynomial regression, or any combination of the approaches seen above in this subsection.

See section \@ref(fig:GAMPlotLab7.8.3) for explanation of interpretation of the plots.

__Disadvantages of GAM:__ 

1. The fitting procedure holds the other variables fixed, hence it does not count for interactions. Therefore, one may manually construct interaction variables to account for this, just like in mulitple linear regression.
2. Prediction wise it is not competitive with Neural Networks and Support Vector Machines.

__Advantages of GAM:__ 

1. Allowing to fit non linear function for j variables ($f_j$)
2. Has potential of making more accurate predictions
3. As the model is additive (meaning that each function is fitted holding the other variables fixed) we are still able to make inference, e.g., assessing how one variable affects the y variable.
4. Smoothness of function $f_j$ can be summarized with degrees of freedom.
5. Often applied when aiming for explanatory analysis (instead of prediction)


#### GAM for classification problems

When y is qualitative (categorical), GAM can also be applied in the logistical form.

As discovered in the classification section, we can apply logits (log of odds) and odds, see material from first semester.

The same advantages and disadvantages as in the prior section applies.


## Lecture notes

+ Talking about polynomials and what they are, e.g., can be parabula, etc.

+ With splines we set polynomials in each of the X regions. Where just polynomial regression is fitted to the whole dataset, and not just in regions.

+ By default poly() will make orthogonal polynomials. Meaning that it tries to create orthogonal terms, where the polynomials are orthogonal (not related to each other). As that is default, then we have to define, that we want to use raw data, hence raw = TRUE, hence we will get the regular polynomials of the dataa.

+ See notes in her R file.


General Wrap-Up

+ The approaches are similar
+ Must be aware of why the models are used
+ Try them out
+ Assess how they look


## Lab section

Loading the data that will be used throughout the lab section.

```{r}
library(ISLR)
attach(Wage)
df <- Wage
```

\

### Polynomial Regression and Step Functions

#### Continous model

Fitting the model:

```{r}
fit <- lm(wage ~ poly(age,4) #Orthogonal polynomials
          ,data = df)
fit2 <- lm(wage ~ poly(age,4,raw = TRUE) #Orthogonal polynomials
          ,data = df)
```

Note: `poly()` returns orthogonal polynomials, which is some linear combination of the variables to the d power. See the following two examples when using orthogonal and normal polynomials:

```{r}
{
  print("Orthogonal")
  cbind(df$age,poly(x = df$age,degree = 4))[1:5,]  %>% print()
  print("Regular")
  cbind(df$age,poly(x = df$age,degree = 4,raw = TRUE))[1:5,] %>% print()
}
```

In the end, it does not have a noticeable effect.

```{r}
options(scipen = 5)
{
  coef(summary(fit)) %>% print()
  coef(summary(fit2)) %>% print()
}
```

Even though the coefficients are different and the p-values hereof, the fitted values will be indistinguishable [@hastie2013, 288]. This is also shown later.


_Alternatives to using `poly()`??_

We have two alternatives:

1. Using `I()`
2. Using `cbind()`

1. Using `I()`

```{r}
fit2a <- lm(wage ~ age + I(age^2) + I(age^3) + I(age^4) #Note that 'I()' is added
            ,data = df)
coef(fit2a)
```

_Notice `I()` as '^' has another special meaning in formulas_

Hence we see that the coefficients are the same.

2. Using `cbind()`

```{r}
fit2b <- lm(wage ~ cbind(age,age^2,age^3,age^4)
            ,data = df)
coef(fit2b)
```

We see that we are now able to use '^' within the `cbind()`.

\

proceeding with the lab sections. We can now present a grid of values for age, at which we want predictions and then call the `predict()` and also plot the standard errors.

```{r}
agelims <- range(df$age) #The min and max
age.grid <- seq(from = agelims[1],to = agelims[2]) #Creating a counter within the range
preds <- predict(object = fit
                 ,newdata = list(age = age.grid) #Creating a list with the counter named age, so it fits the IV naming
                 ,se.fit = TRUE)
se.bands <- cbind(preds$fit + 2*preds$se.fit #Upper band
                  ,preds$fit-2*preds$se.fit) #Lower band
```

Notice that 2 SE (2 sd) = 95%, hence we expect to contain 95% of the data within confidence levels.

Now we can plot the data

```{r}
plot(x = df$age,y = df$wage
     ,xlim = agelims
     ,cex = 0.5 #Size of dots
     ,col = "darkgrey")
title("Degree-4 Polynomial",outer = TRUE)
lines(x = age.grid,y = preds$fit
      ,lwd = 2
      ,col = "blue")
```


___Comparison between raw polynomials and orthogonal polynomials___

With the following we see that the difference of the fitted values are practically 0.

```{r}
preds2 <- predict(object = fit2
                  ,newdata = list(age = age.grid)
                  ,se.fit = TRUE)
max(abs(preds$fit-preds2$fit))
```

In terms of predictions, the two approaches are more or less the same, although the orthogonal polynomials removes some effect of collinearity.

\


________________

**Assessing what polynomial to include**

Now we can compare models with different orthogonal polynomials. Using ANOVA, which compare the RSS to see if the decrease in RSS is significant.

```{r}
fit.1 <- lm(wage~age,data=df)
fit.2 <- lm(wage~poly(df$age,2),data=df)
fit.3 <- lm(wage~poly(df$age,3),data=df)
fit.4 <- lm(wage~poly(df$age,4),data=df)
fit.5 <- lm(wage~poly(df$age,5),data=df)
anova(fit.1,fit.2,fit.3,fit.4,fit.5)
```

_Note, _

+ _the anova compares the sum of resduals squared._
+ _the anova follows an F distribution, hence we could apple the critical values_


based on the anova we see that the errors change significantly until the 5th degree, hence the decision should be to take the model with order 4 of polynomials.

Notice, that the model will never become worse in sample when complexity is added, as we fit the model more to the data.


_Alternative_

We could also have obtained the same output using `coef()` instead of the anove, where we see that teh p-values are the same, also the squared value of t ($t^2=F$).

```{r}
coef(summary(fit.5))
```

_Notice: this is only an alternative when we exclusively have polynomials in the model!_

********

\


**Using ANOVA to assess for best models**

The following is another example of using ANOVA where different variables are used:

And recall, that we should never apply p-values of variables in a model, to decide which that should be included.

**NOTE; this approach only works when the models are nested, meanin that the overall variables are the same, hence M2 could not have regian for instance, they all need to have the same overall variable**

```{r}
fit.1 = lm(wage~education +age ,data=df)
fit.2 = lm(wage~education +poly(age ,2) ,data=df)
fit.3 = lm(wage~education +poly(age ,3) ,data=df)
anova(fit.1,fit.2,fit.3)
```

What are we looking for? 

1. What model lowers the RSS significantly.


**Using CV**

We could also have chosen the order of polynomials using cross validation.

```{r}
library(boot)
set.seed(19)
cv.error = rep (0, 5)
for (i in 1:5)
  {
  fit.i=glm(wage~poly(age,i),data=Wage)  # notice glm here in conjunction with cv.glm function
  cv.error[i]=cv.glm(Wage, fit.i, K=10)$delta[1] #K fold CV
}
cv.error # the CV errors of the five polynomials models
```

Concl: A 5 order model is not justified as the it starts increasing. Also we see that the 4th order d, is the best, which corresponds with previous findings.



#### Logarithmic model

The procedure is per se the same, but now we are working with a probabilistic model instead of. Hence the outcome must be binary. Thus, it is decided to predict whether a persons wage is higher or lower than 250.


```{r}
fit <- glm(I(wage > 250) ~ poly(age,4) #Note the use of I()
           ,data = df
           ,family = binomial)
```

Note, that again `I()` is used, where the expression is evaluated on the fly, one could naturally also had made a vector of the classes.

_Note, by default `glm()` will transform TRUE and FALSE to respectively 1 and 0._

Now we can make predictions, which are logits, these can be used for much, hence later we will transform them into probabilities.

```{r}
preds = predict(fit
                ,newdata = list(age=age.grid)
                ,se.fit = TRUE)
                # We could have added type = response to get probabilities

preds$fit[1:10]#First 10 logits
```

To make confidence intevals for Pr(Y = 1|X), i.e.

\begin{equation}
Pr(Y=1|X)= \frac{exp(X\beta)}{1+exp(X\beta)}
(\#eq:LogConfidenceinterval)
\end{equation}

Where $X\beta$ can be explained by:

\begin{equation}
log(\frac{Pr(Y=1|X)}{1-Pr(Y=1|X)})=X\beta
(\#eq:XBeta)
\end{equation}

Hence we must first calculate $X\beta$ to find Pr(Y=1|X).

```{r}
#Making Prbabilities
pfit = exp(preds$fit)/(1+exp(preds$fit)) #See equation above

#X beta
se.bands.logit = cbind(preds$fit+2*preds$se.fit #Upper level
                       ,preds$fit-2*preds$se.fit) #Lower level

#Pr(Y = 1|X)
se.bands = exp(se.bands.logit)/(1+exp(se.bands.logit))
```

Remember that 2 SE = 95%, thus with the confidence levels we expect to contain 95% of the data.

Notice, that the posterior probabilities could also have been found by using `predict()`, see the following:

```{r}
preds = predict (fit
                 ,newdata = list(age = age.grid)
                 ,type = "response" #Getting probabilities instead of logits
                 ,se.fit = TRUE)
```

**NOTICE: for some reason this will lead to wrong confidence intervals [@hastie2013,292], thus we prefer the regular approach, as shown before**

Now we can make the right hand plot, so we can compare with continous result.

```{r}
par(mfrow = c(1,2)
    ,mar = c(3,4.5,4.5,1.1) #Controls the margins
    ,oma = c(0,0,4,0)) #Controls the margins
#Copy from earlier to combine plots
fit <- lm(wage ~ poly(age,4) #Orthogonal polynomials
          ,data = df)
preds <- predict(object = fit
                 ,newdata = list(age = age.grid)
                 ,se.fit = TRUE)
plot(x = df$age,y = df$wage
     ,xlim = agelims
     ,cex = 0.5 #Size of dots
     ,col = "darkgrey")
title("Degree-4 Polynomial",outer = TRUE)
lines(x = age.grid,y = preds$fit
      ,lwd = 2
      ,col = "blue")

#The new plot
plot(x = age,y = I(wage >250)
     ,xlim = agelims
     ,type ="n"
     ,ylim = c(0,.2))

points(jitter(age)
       ,I((wage>250)/5)
       ,cex = .5
       ,pch = "|"
       ,col = "darkgrey")

lines(x = age.grid,y = pfit
      ,lwd = 2
      ,col= "blue")

matlines(x = age.grid
         ,y = se.bands
         ,lwd = 1
         ,col = "blue"
         ,lty = 3)
```

We see on the right hand panel that the all the observations that have a wage above 250 is in the top and all those below hare in the bottom of the visualization. Although at the tail, we aren't able to conclude much, as confidence interval is really high, hence it can both be high and low earners.

`jitter()` is merely an approach to avoid observations to overlap each other.


#### Step function

To fit the step function we must do:

1. Define the cuts, `cut()` is able to automatically pick cutpoints. One could also use `break()` to define where the cuts should be.
2. Train the model. Notice, that `lm()` will automatically create dummy variables for the ranges.

```{r}
{table(cut(df$age,4)) %>% print()
fit <- lm(wage ~ cut(df$age,4)
          ,data = df)
coef(summary(fit)) %>% print()}
```

We see that the p value of the cuts are significant, not that we can use the p-values for much.

Notice, that the first range is the base level, thus it is also left out. We can then use the intercept as the average wage for all in the range of up to 33.5 years.

Hence for a 40 year old person, the model will say that he has an wage of 94 + 24 = 118

```{r}
rm(list = ls())
```


### Splines

The different approaches to splines are presented in the following.

#### Basis Function Splines

```{r}
library(ISLR)
df <- Wage
library(splines)
agelims <- range(df$age) #The min and max
age.grid <- seq(from = agelims[1],to = agelims[2]) #Creating a counter within the range
```

The splines library contain what we need. We introduce the following functions:

+ `bs()`: Basis functions for splines. Generates entire matrix of basis functions for splines with the specified set of knots.
+ `ns()`: Natural splines.
+ `smooth.spline()`: Used when fitting smoothing splines.
+ `loess()`: When fitting local regression.

Note, that by default the splines will be choosen to be 3, this can also be found in the function documentation.

```{r}
par(mfrow = c(1,1),oma = c(0,0,0,0))
fit.bs <- lm(wage ~ bs(age,knots = c(25,40,60)) #we just chose the knots randomly
             ,data = df)
pred.bs <- predict(fit.bs
                 ,newdata = list(age = age.grid)
                 ,se.fit = TRUE)
plot(df$age
     ,df$wage
     ,col = "gray")

lines(age.grid
      ,pred.bs$fit
      ,lwd = 2)

lines(age.grid
      ,pred.bs$fit+2*pred.bs$se
      ,lty = "dashed")

lines(age.grid
      ,pred.bs$fit-2*pred.bs$se
      ,lty = "dashed")

title("Splines - Basis Functions")
```

We see that the splines have been fitted to the data and notice that the tails have wider confidence intervals.

We can get the amount of degrees of freedom by calling the `dim()`function.

```{r}
{
  #Specifying the knots
  dim(bs(age,knots = c(25,40,60))) %>% print()
  
  #df can be specified instead of knots
  dim(bs(age,df = 6)) %>% print()
}
```

We see that the two alternatives produce the same results.

Notice, that there are packages that will optimize the amount of knots.

We can assess where the `bs()` placed the knots, by calling the `attr()`.

```{r}
attr(bs(age,df=6),"knots")
```

In this case, R chose the 25%, 50% and 75% quantiles.


#### Natural Splines

It similar to bs(), but it has an additional condition. I did not really get it.

The fitting procedure is the same, but now we just use `ns()` instead of `bs()`.

```{r}
fit.ns = lm(wage ~ ns(age
                      ,df = 4 #Note, as with bs() we could have specified the knots instead of.
                      )
            ,data = df)

pred.ns = predict(fit.ns
                  ,newdata = list(age=age.grid)
                  ,se.fit = TRUE)

#Copy of old plot
  plot(df$age
       ,df$wage
       ,col = "gray")
  
  lines(age.grid
        ,pred.bs$fit
        ,lwd = 2)
  
  lines(age.grid
        ,pred.bs$fit+2*pred.bs$se
        ,lty = "dashed")
  
  lines(age.grid
        ,pred.bs$fit-2*pred.bs$se
        ,lty = "dashed")

#Adding natural splines
lines(age.grid
      ,pred.ns$fit
      ,col ="red"
      ,lwd =2)

title("Splines - Basis Functions + Natural Splines")
legend("topright",c("Basis","Natural"),lty = 1,col = c("Black","Red"),cex = 0.6)
```


#### Smooth Splines

As we discovered in the first part of the chapter, it sets a knot at each observation, and then we will penalize the function with a lamda ($\lambda$), to avoid overfitting.

The code show the procedure.

```{r}
#Hardcoding degrees of freedom
fit.ss <- smooth.spline(x = df$age,y = df$wage
                     ,df = 16) #Remember that we must impose constraints

#Choosing smoothing param with CV
fit.ss2 <- smooth.spline (df$age
                          ,df$wage
                          ,cv = TRUE) #we choose cv instead of fixed amount of df
fit.ss2$df
```

We get sparsity hence we have degrees of freedom of 6.8. That is due to the tuning parameter which was found by the cross validation proces. We can find the specific lambda value with the following:

```{r}
fit.ss2$lambda
```


```{r}
plot(age,wage
     ,xlim = agelims
     ,cex = .5
     ,col = "darkgrey")
title("Smoothing Spline")

lines(fit.ss,col = "red",lwd = 2)
lines(fit.ss2,col = "blue",lwd =2)

legend("topright",legend = c("16 DF","6.8 DF")
       ,col = c("red","blue")
       ,lty = 1
       ,lwd = 2
       ,cex = .8)
```

As expected, we see that the more complex model (highest amount of df) is the more flexible model.

Note: tuning parameter = $\lambda$, where the CV seeks to choose the parameter that leads to the lowest error and return the df that leads to this level.


#### Local Regression

Recall that local regression makes a linear regression for the observations that are close to the observation under evaluation ($x_0$).

Thus we have to specify the span, the larger the span the smoother the fit, as we will include more observations.

NB: `locfit` library can also be used for fitting local regress

```{r}
plot(x = df$age,y = df$wage
     ,xlim = agelims
     ,cex = .5
     ,col = "darkgrey")
title ("Local Regression")

fit.lr <- loess(wage ~ age
                ,span = .2 #Degree of smoothing / neighborhood to be included
                ,data = df)

fit.lr2 <- loess(wage ~ age
              ,span = .5 #Degree of smoothing / neighborhood to be included
              ,data = df)

lines(x = age.grid,y = predict(object = fit.lr,newdata = data.frame(age=age.grid))
      ,col = "red"
      ,lwd = 2)

lines(x = age.grid,y = predict(object = fit.lr2,newdata = data.frame(age=age.grid))
      ,col =" blue"
      ,lwd = 2)

legend(x = "topright"
       ,legend = c("Span = 0.2","Span = 0.5")
       ,col=c("red","blue")
       ,lty = 1
       ,lwd = 2
       ,cex = .8)
```

From the plot we also see that the model with the largest span has the smoothest fit.


### GAMs

We want to predict wage, where year, age and education (as categorical) as predictors.


#### With only natural splines

According to the @hastie2013, 294, this is just a bunch of linear functions, hence we can merely apply `lm()`, see the following.

```{r}
gam.m1 <- lm(wage ~ ns(year,df = 4) + ns(age,df = 5) + education #NOTICE, that we just use lm()
             ,data = df)
summary(gam.m1)
```

From the summary we see the variables that have been created and also the factor levels for education.

Again, we don't have to interprete the coefficients, we just need to look at the shape.


#### With different splines

Now we have to apply the package `gam`.

**This is the best approach.**

```{r}
library(gam)
```

We can also construct a GAM model, that contains smoothing splines, that is done by calling `s()`. Where year and age will be included with up to 4 and 5 degrees of freedom.

```{r}
gam.m3 <- gam(wage ~ s(year,df = 4) + s(age,df = 5) + education
              ,data = df)
```

Remember, that GAM fits each variable while holding all other variables fixed. The actual fitting procedure is called backfitting, and fits variables by repeatedly updating the fit for each predictor [@hastie2013, 284-285]. Hence, we create plots to interprete how.

```{r GAMPlotLab7.8.3,fig.cap="GAM plot and intepretation"}
par(mfrow = c(1,3))
plot(gam.m3 #Note, automatically identifies the GAM object, hence plots for each variable
     ,se = TRUE
     ,col ="blue")
```

Interpreting the plot: Recall that the plots assumes that we hold the other variables fixed, hence we see the following:

- Left: We see that holding education and age fixed, the wage tends to increase over the years, that is quite natural, e.g., because of inflation.
- Center: Holding year and education fixed, we see that the wage tends to be highest in the middle region around 40-45 years of age. That is also quite intuitive that the wage first increase and then decreasing as the person gets closer to the retirement age.
- Right: Holding year and age fixed, we see that the higher education you have, the higher will your wage be.


```{r,fig.cap="GAM of natural splines"}
par(mfrow = c(1,3))
plot.Gam(gam.m1
         ,se = TRUE
         ,col = "red")
```

Notice, that this plot looks very similar to \@(fig:GAMPlotLab7.8.3).

This command could naturally also be used for the other GAM object, it is just that `plot()` does not automatically identify, that it is in fact intended to be interpretet as a GAM.


#### But what variables to include?

It looks as is year is rather linear. To make this assessment, we can apply an ANOVA test of the different combinations. Hence:

*Note, the first model is nested in the second model (has the same variables), hence we can use ANOVA*

```{r}
#Excluding year
gam.m1 <- gam(wage ~ s(age,df = 5) + education
             ,data = df)

#Including year, but as a linear
gam.m2 <- gam(wage ~ year + s(age,df = 5) + education
             ,data = df)

anova(gam.m1,gam.m2,gam.m3,test = "F")
```

We see that performance is significantly better going from model 1 to model 2, but on a five percent level, we are able to say, that we don't gain anything with the third model, which is most complex model.

Thus, the linear constellation of year, with polynomials on age + education as factors, appear to be the best performing model.

With this in mind, it is interesting to assess the summary of the complex model:

```{r}
summary(gam.m3)
```

Looking at the section: "Anova for Nonparametric Effects", we see that the smoothing spline on year, is not significant, hence it supports the conclusion from above, that we are better off, including the year as a linear variable.

Now we can make predictions.

```{r}
#Predictions with linear year, non linear age and factors of education
preds <-predict(gam.m2
                ,newdata = df)
```


#### GAM with local regression

We are also able to make GAM on other building blocks, for instance local regression, that will be shown in the following

For some reason the following cant be run.

```{r}
#GAM with local regression

gam.lo <- gam(wage ~ s(df$year,df = 4) + lo(df$age,span = 0.7) + education
               ,data = df)

# plot.Gam(gam.lo #For some reason it cant be plotted
#          ,se = TRUE
#          ,col = "green")
```


Making interactions in the local regression:

```{r}
gam.lo.i <- gam(wage ~ lo(year,age,span = 0.5) + education
                ,data = df)

library(akima) 
plot(gam.lo.i)
```


#### Logistic Regression

Plotting logistic regression GAM, here we can apply `I()` as previous used, to make the expression on the fly.

```{r}
gam.lr <- gam(I(wage > 250) ~ year + s(age,df = 5) + education
              ,family = binomial
              ,data = df)

par(mfrow =c(1,3))
plot(gam.lr,se=T,col =" green ")
```

One could interprete the plot and assess each window to see how the variable influence the decision wether the observation is above or below. Remember that the outcome can be seen as probabilities, these can also be plotted to be shown the spread:

```{r}
par(mfrow = c(1,1))
plot(gam.lr$fitted.values)
```


From th plot, we see that there is a tendency that the lower the education the lower the wage, the following table show how the high earners are distributed.

```{r}
table(education,I(wage > 250))
```

We see that there are no people with less than high school degree that earns more than 250.

To get more sensible result, we can remove the observations with a low degree, this will also show a more sensible result for the other degrees, see the following.

```{r}
gam.lr.s = gam(I(wage > 250) ~ year + s(age,df = 5) + education
               ,family = binomial
               ,data = df
               ,subset = (education != "1. < HS Grad")) #removing people in the lowest group of education.
par(mfrow = c(1,3))
plot(gam.lr.s
     ,se = TRUE #Standard errors
     ,col =" green ")
```



Do we need a nonlinear term for year?
Use anova for comparing the previous model with a model that includes a smooth spline of year with df=4

We can do an ANOVA, but please notice, we use Chi Square now.

```{r}
gam.y.s = gam(I(wage>250) ~ s(year, 4) + s(age,5) + education,family=binomial,data = df,subset=(education!="1. < HS Grad")) 
anova(gam.lr.s,gam.y.s, test="Chisq") #  Chi-square test as Dep variable is categorical
```

We do not need a non-linear term for year.



## Exercises

### Exercise 6

**Purpose, to practice polynomial regression and step functions**

```{r}
library(ISLR)
df <- Wage
```

#### 6.a Polynomial Regression

We use orthogonal polynomials in the modeling process as we know that these are slightly better than raw polynomials due to the fact that this tend to avoid collinearity.

Training the model

```{r}
library(boot) #For the cv.glm() function
set.seed(1337)
cv.error = rep (0,10)
for (i in seq(from = 1,to = length(cv.error),by = 1)) {
  #Training
  fit.i <- glm(wage ~ poly(age,i),data = df)  # notice glm here in conjunction with cv.glm function
  
  #Performing cross validation
  cv.error[i] <- cv.glm(data = df,glmfit = fit.i,K = 10)$delta[1] #K fold CV, delta = prediction errer i.e. MSE
  }

#Printing the 
cv.error # MSE the CV errors of the five polynomials models
```

The vector above are all of the prediction errors computed in the loop.

```{r}
which.min(cv.error)
```


We see that the fifth prediction appear to yield the lowest MSE, but is it significantly different than e.g. forth or third order polynomial?

```{r}
fit.1 <- glm(wage ~ poly(age,1),data = df) 
fit.2 <- glm(wage ~ poly(age,2),data = df) 
fit.3 <- glm(wage ~ poly(age,3),data = df) 
fit.4 <- glm(wage ~ poly(age,4),data = df) 
fit.5 <- glm(wage ~ poly(age,5),data = df) 
anova(fit.1,fit.2,fit.3,fit.4,fit.5,test = "F")
```

***We can only use these as the models are nested as the variables are the same***

Using the F test, we see that on a five percent level the 4th polynomial is not justified, but close to. This argues that we should select the third order of polynomials as that is the last where there is statistical evidence for lowering the residuals.

Thus we select a model with three polynomials. Plotting the errors, we also see that there does not happen much after the third polynomial. We also plotted the standard errors and thus we are able to select based on this.

```{r}
plot(cv.error,type = "b")
min.point = min(cv.error)
sd.points = sd(cv.error)
abline(h=min.point + 0.2 * sd.points, col="red", lty="dashed") #0.2 is just a rule of thumb, could be anything
abline(h=min.point - 0.2 * sd.points, col="red", lty="dashed")
legend("topright", "0.2-standard deviation lines", lty="dashed", col="red")
```

Thus, there is even more information supporting selecting three degrees of freedom.


**Plotting the polynomial regression**

This is done with the following procedure:

1. Make a grid counting IDV (Age)
2. Make predictions
3. Make a plot with the variables
4. Fit a line onto the predictions
5. Perhaps calculate confidence levels and plot these

```{r}
#Grid of X
age.grid <- seq(from = min(df$age),to = max(df$age),by = 1)

#Predictions
preds <- predict(object = fit.3
                 ,newdata = list(age = age.grid) #Renaming age.grid to age
                 ,se.fit = TRUE) #We want to produce confidence levels

#Plotting
plot(x = df$age,y = df$wage,col = "darkgrey",cex = 0.8)
grid()
lines(x = age.grid #We need to define the grid, otherwise the fit will not be alligned with the data
      ,y = preds$fit
      ,col = "red")
title("Polynomial of 3rd order")

```


#### 6.b Step function

```{r}
cuts <- 4

#Cutting the x variable
table(cut(df$age
          ,breaks = cuts))
  #' Note, this only shows where the cuts lie and how many there are in each


#Fitting the step function
fit.step <- lm(wage ~ cut(df$age,4)
               ,data = df)

coef(summary(fit.step))
```

We see that the the first cut (bin with people up to 33,5) have been left out. That is because they are contained in the intercept.

Now we can fit the step function

```{r}
library(stats)

#Predictions
preds <- predict(object = fit.step
                 ,newdata = list(age = age.grid)) #Renaming age.grid to age

#Plotting
# plot(x = df$age,y = df$wage,col = "darkgrey",cex = 0.8)
# grid()
# lines(age.grid
#       ,preds
#       ,col = "red")
# title("Step function of 3rd order")
```

I need to check what she is doing, one could perhaps manually order the 

```{r,include=FALSE}
rm(list = ls())
```

### Exercise 7

```{r}
df <- Wage
```


Evaluating features other features to see how age respond hereon.

We can plot the variables agains each other, to see how they interact.

```{r}
library(dplyr)
for (i in 1:10) {
  plot(y = df$wage,x = df[,i],xlab = names(df)[i],ylab = "Wage")
  grid()
  names(df)[i] %>% title()
}
```

Looking at race, it appears as if there is some relationship between race and wage the same with maritial status. Region only has values in one category, jobclass appear to visually have different means. The same goes for health and health insurance. Naturally log of wage has a non linear relationship with wage. Although the variable is the same, thus it cant be used for much to predict wage levels.

Since all the variables of interest, and we haven't worked with are all categorical, then we can't really do any polynomial regression with the data, as they are all factors.

What one could do is a mutlivariate linear model with different factors, or step functions or perhaps GAM where a continous varaible with polynomials are included.

Therefore, I will not elaborate much more on this.

Ana made three different models, notice, that these are linear models, as the polynomial regression is not able to handle this.

```{r}
fit1 = lm(wage ~ maritl, data = df)
deviance(fit1) # here deviance = RSS

fit2 = lm(wage ~ jobclass, data = df)
deviance(fit2)

fit3 = lm(wage ~ maritl + jobclass, data = df)
deviance(fit3)# Select model fit3 (smallest deviance)

summary(fit3)
```

We can assess the groups with the contrasts function.

```{r}
# To interpret first identify which is ref category
contrasts(Wage$maritl) # Never Married is the reference category
contrasts(Wage$jobclass) # Industrial is the reference category
```


Anova can also show the deviances etc. but notice, these does not appear to be neste d(JK note)?????

+ The answer, fit 1 and fit 2 are nested into fit 3. Thus we dont compare fit 1 and fit 2, as these are not nested.

```{r}
anova(fit1,fit2,fit3)
```


Now we can check the residuals

```{r}
par(mfrow = c(2,2))
plot(fit3)
```

Looking at: 

+ The top left of the plot (residuals vs fitted), we would like these to be around 0.
+ The top right, we want them to have a linear shape. This looks odd

Based on this, the model may be questionable. The solution:

+ Exclude the extreme values
+ Finding a variable that account for them.

```{r,include=F}
rm(list = ls())
```


### Exercise 8

```{r}
df <- Auto
```

Are we able to predict how old a car is based on the variables at hand?

Hence year = DV

Name contains a lot of value, let us only use the first word, as that appear to be the brand. Therefore a loop is created to correct all the misspelled names.

```{r}
brand <- strsplit(x = as.character(df$name),split = " ")

brand.name <- as.vector(rep(0,length(brand)))

for (i in c(1:length(brand))) {
  brand.name[i] <- brand[[i]][1]
}

table(brand.name)

misspelled <- matrix(byrow = TRUE,ncol = 2
                     ,data = c("mercedes","mercedes-benz"
                              ,"toyouta","toyota"
                              ,"chevroelt","chevrolet"
                              ,"maxda","mazda"
                              ,"vokswagen","volkswagen"
                              ,"vw","volkswagen"))

index <- as.vector("")
n <- 0
bn.list <- as.list(0)
brand.name.recent <- brand.name
for (i in c(misspelled[,1])) {
  n <- n + 1
  index <- rep(FALSE,length(brand.name))
  index[brand.name == i] <- TRUE
  bn.list[[n]] <- replace(x = brand.name.recent,list = index,values = misspelled[n,2])
  brand.name.recent <- replace(x = brand.name.recent,list = index,values = misspelled[n,2])
}
df <- cbind(df[,-9],as.factor(bn.list[[6]]))
names(df)[names(df) == 'bn.list[[6]]'] <- "brand.name"
```

Also we must convert origin to a factor.

```{r}
df$origin <- as.factor(df$origin)
```

Checking correlations.

The following can be run to see all the combinations

```{r}
# par(mfrow = c(1,1))
# for (i in 1:dim(mm)[2]) {
#   plot(y = df$year,x = mm[,i],xlab = names(mm)[i],ylab = "Year")
#   grid()
#   colnames(mm)[i] %>% title()
# }
```

Before training the model, we can partition the data to test the model out of sample

```{r}
set.seed(1337)
train.size <- round(x = nrow(df)*0.8,digits = 0) #Setting the training size
train.index <- sample(x = c(1:nrow(df)),size = train.size) #setting seed and creating vector for index
mm <- model.matrix(year ~ .,data = df)[,-1] #tried to make it mm first, to get rid of having variables that were in one partition but not the other.
year <- df$year
train.df <- as.data.frame(cbind(year,mm[train.index,])) #crating the training set
test.df <- as.data.frame(cbind(year,mm[-train.index,])) #creating the testing set
```


```{r}
library(gam)

gam.m1 <- gam(year ~ s(train.df$mpg,df = 5) + s(train.df$cylinders,df = 5) + s(train.df$displacement,df = 5) + s(train.df$horsepower,df = 5) + s(train.df$weight,df = 5) + s(train.df$acceleration,df = 5) + .
           ,data = train.df)

summary(gam.m1)
```

It appears as if non of the parameters are good predictors.

Then one could try out other models, or perhaps it is just very difficult with the data at hand to predict the year of the car.


```{r,include=F}
rm(list = ls())
```


### Exercise 9

```{r}
library(MASS)
df <- Boston
df <- as.data.frame(cbind(df$nox,df$dis))
colnames(df) <- c("nox","dis")
```

#### (a) using poly function to fit cubic polynomial regression

```{r}
fit.poly <- lm(nox ~ poly(dis,3),data = df)
summary(fit.poly)
```

Remember that we are not interested in the coefficients as they are misleading, thus we want to look at the shape.

The table above is mostly presented for explanatory reasons.

As we are interested in the curve, we can fit that.

```{r}
#Defining range
dislims <- range(df$dis)
n <- (dislims[2]-dislims[1])/nrow(df)
dis.grid <- seq(from = dislims[1],to = dislims[2],by = n)

#Predictions for the plot
preds <- predict(object = fit.poly,newdata = list(dis = dis.grid))

#Plotting
plot(nox ~ dis, data = df, col = "darkgrey")
grid()
lines(x = dis.grid,y =  preds, col = "blue",lwd = 2)
title("Cubic polynomial")
```



#### (b) Plotting polynomial fits for a range of polynomials

```{r}
models <- list()
RSS <- 0
for (d in 1:10) {
  models[[d]] <- lm(nox ~ poly(dis,d),data = df)
  RSS[d] <- sum(residuals(models[[d]])^2)
}
plot(RSS,type = "b")
points(x = which.min(RSS),y = RSS[which.min(RSS)],col = "red",pch = 19)
grid()
abline(h = min(RSS),col = "blue",lty = 2)
title("In-sample error")
```

We see that the RSS decrease with complexity, that it as expected, as we fit to the in sample data. We could do this with a partition of the data to see out of performance instead.


#### (c) Using CV to select best degree of d

Here we run a loop with cross validation to see how the different order of d performs. As the partitions are randomly selected, we preduce 10 simulations to see which orders that tend to occur most often.

```{r}
models <- list()
RSS <- 0
CV.RSS <- 0
CV.RSS.sim <- 0

for (i in 1:20) {
  for (d in 1:10) {
  models[[d]] <- glm(nox ~ poly(dis,d),data = df)
  RSS[d] <- sum(residuals(models[[d]])^2)
  CV.RSS[d] <- cv.glm(data = df,glmfit = models[[d]],K = 10)$delta[2] #Delta = prediction error (adjusted)
  }
  
  CV.RSS.sim[i] <- which.min(CV.RSS)
}

#Plotting prediction error
plot(CV.RSS,type = "b")
points(x = which.min(CV.RSS),y = CV.RSS[which.min(CV.RSS)],col = "red",pch = 19)
grid()
abline(h = min(CV.RSS),col = "blue",lty = 2)
title("CV K = 10 prediction error")

#Plotting simulations
barplot(table(CV.RSS.sim),xlab = "Degree of d",ylab = "Frequency")
abline(h = 0)
title("CV K = 10, Iterations = 20")
```

In these simulations we see that the best fit is likely to be with using .

It is actually quite interesting that a model with 10 degrees of d is as competitive as 4 in this example, although the cubic model is far superior than the other models.

#### (d) Use `bs()` to fit a regression spline

```{r}
par(mfrow = c(1,1))
fit.bs <- lm(nox ~ bs(dis,df = 4),data = df) #Note as degree is not defined, default = 3
preds <- predict(object = fit.bs,newdata = list(dis = dis.grid))
plot(x = df$dis,y = df$nox,col = "darkgrey",pch = 20,ylab = "nox",xlab = "dis")
lines(x = dis.grid,y = preds,col = "blue",lwd = 2)
grid()
title("Regression Spline df = 4")
abline(v = 3.20745,col = "red",lty = 2) #This is the cut, found in next chunk
legend(x = "topright",legend = c("fit","cut"),lty = 1:2,col = c("blue","red"))
```

Notice that we merely specified the amount of df that we wanted. The function merely specified them automatically. We can interpret these, by using `dim()` and `attr()`.

```{r}
print(dim(bs(df$dis,df = 4)))
attr(bs(df$dis,df = 4),"knots")
```

We see that a model with 4 degrees of freedom yields one cut. Where the model put this at 50%, hence the first half (up to 3.20745). For simplicity, this cut has been added to the plot above, to show where the spline is split.


#### (e) Now fit a regression spline 

```{r}
par(mfrow = c(2,2))
for (d in 4:7) {
  #The fit + preds
  fit.bs <- lm(nox ~ bs(dis,df = d,degree = 3),data = df)
  preds <- predict(object = fit.bs,newdata = list(dis = dis.grid))
  
  #Cut
  cut <- attr(bs(df$dis,df = d),"knots")
  
  #Plot
  plot(x = df$dis,y = df$nox,col = "darkgrey",pch = 20,ylab = "nox",xlab = "dis")
  lines(x = dis.grid,y = preds,col = "blue",lwd = 2)
  grid()
  title(paste("Cubic Regression Spline, df =",d))
  abline(v = cut,col = "red",lty = 2) #This is the cut, found in next chunk
  legend(x = "topright",legend = c("fit","cut"),lty = 1:2,col = c("blue","red"))
}
```

We start at four degrees of freedom as a model with only three degrees of freedom, hence cubic regression (three orders of polynomials) = three degrees of freedom **(this has to be fact checked)**.

As we add complexity with knots we also adds degrees of freedom, where we add one degree of freedom for each cut, hence for the cubic spline with 7 degrees of freedom, four cuts and three polynomials **(this has to be fact checked)**.


#### (f) Perform cross-validation, to select degrees

```{r}
models <- list()
RSS <- 0
CV.RSS.sim <- 0

for (i in 1:20) {
  for (d in 4:15) {
  models[[d]] <- glm(nox ~ bs(dis,df = d,degree = 3),data = df)
  RSS[d] <- sum(residuals(models[[d]])^2)
  CV.RSS[d] <- cv.glm(data = df,glmfit = models[[d]],K = 10)$delta[2] #Delta = prediction error (adjusted)
  }
  
  CV.RSS.sim[i] <- which.min(CV.RSS)
}

par(mfrow = c(1,1),mar = c(5,4.5,4.5,2.1),oma = c(0,0,0,0))

#Plotting prediction error
plot(CV.RSS,type = "b")
points(x = which.min(CV.RSS),y = CV.RSS[which.min(CV.RSS)],col = "red",pch = 19)
grid()
abline(h = min(CV.RSS),col = "blue",lty = 2)
title("CV K = 10 prediction error")

#Plotting simulations
barplot(table(CV.RSS.sim),xlab = "Degree of d",ylab = "Frequency")
abline(h = 0)
title("CV K = 10, Iterations = 20")
```

First we see the last iteration and the prediction error hereof. Overall we see that it tend to be the rather complex models tend to be

### Exercise 10

#### (a) Partitioning the data

```{r}
#Loading
df <- College

#Partitioning
set.seed(1337)
train.size <- round(x = nrow(df)*0.8,digits = 0) #Setting the training size
train.index <- sample(x = c(1:nrow(df)),size = train.size) #setting seed and creating vector for index
train.df <- df[train.index,] #crating the training set
test.df <- df[-train.index,] #creating the testing set
rm(train.size)
rm(train.index)
```

Finding the best subset using forward selection

```{r}
reg_null <- lm(Outstate ~ 1,data = train.df) #The null  models
reg_full <- lm(Outstate ~ .,data = train.df) #The full model
step.for <- stepAIC(direction = "forward",object = reg_null,trace = TRUE,scope = list(upper = reg_full,lower = reg_null)) #This could also have been done with regsubsets()
summary(step.for)
```

**NOTE:** Ana's solution has a nice example with regsubsets, where she applies standard errors to see if the results of the different combinations are the same.

We see that the forward selection decides on 14 variables to be included


#### (b) Fitting a GAM

```{r}
par(mfrow = c(1,1))
library(forecast)
best.formula <- formula(step.for)
fit.gam <-gam::gam(formula = best.formula,data = train.df) #Notice that it is linear
preds <- predict(object = fit.gam,newdata = test.df)
plot(x = preds,y = preds-test.df$Outstate,ylab = "Residuals",xlab = "Predicted values")
```

From the plot we see that in general we have a resdiausl around 0 withinn +/- 5000. Also the residuals do look rather normal. Although one could argue that the variance is a but smaller in the lower region of the predicted value, and it does in fact appear as if we are under estimating these result.

We can interprete how Outstate responds in the following:

```{r}
par(mfrow = c(4,4))
plot(fit.gam #Note, automatically identifies the GAM object, hence plots for each variable
     ,se = TRUE
     ,col ="blue")
```

Interpreting the plot: Recall that the plots assumes that we hold the other variables fixed, hence we see the following:

+ e.g., Expend: We see that holding the other variables fixed, the outstate tends to increase over the expenditure.
+ e.g., Apps: I assume that this is applicants, we see that holder the other variables fixed, outstate students tend to decrease as amount of applicants decrease.

We can also assess the overall accuracy

```{r}
accuracy(preds,x = test.df$Outstate)
```

We see that the MAE is 1587, where the mean absolute percentage error is almost 17%, hence it appear to be rather high.

#### (c) Evaluating on the test set

This is what was done above. It is expected that if we compared applying on the train and test set, we will observe that the model has a lot of optimism on the train data, thus we should also see that the MAPE is lower on this partition, has this is what the model was trained on.


#### (d) Which variables appear to have a non linear relationship?

```{r}
par(mfrow = c(3,3))

for (i in c(1:8,10:18)) {
  plot(y = df$Outstate,x = df[,i],xlab = names(df)[i],ylab = "Outstate",pch = 20,col = "darkgrey")
  grid()
  colnames(df)[i] %>% title()
}
```

It appears as if expend has som non linear relationship with Outstate. Perhaps enroll, F.Undergrad, and P.Undergrad also have a non linear trend.

To further decide if there is evidence for a non linear relationship, one could make, e.g., a smoothing model to assess the performance hereof.

```{r}
set.seed(1337)
library(mgcv)
gam.mgcv <- mgcv::gam(Outstate ~ Private + s(Room.Board) + s(PhD) + s(perc.alumni) + s(Expend) + s(Grad.Rate), data = train.df,method = 'REML')
summary(gam.mgcv)
# We look at the Approximate significance of smooth terms table, in particular to edf.
# These edfs suggests that the previous gam model (imposing all nonlinear) may be a little too restrictive 
par(mfrow = c(2, 3))
plot(gam.mgcv, se = T, col = "blue")
# Check residuals diagnostics
par(mfrow = c(2,2))
gam.check(gam.mgcv)
```




## Predicting the Return on Advertising Spent

```{r,echo=FALSE}
detach("package:mgcv", unload=TRUE)
detach("package:gam", unload=TRUE)
```


(Case and data source: kaggle.com)

\

### 1. Background 

Along with Google's search and display networks, Facebook is one of the big players when it comes to online advertising. As Facebook users interact with the platform, adding demographic information, liking particular pages and commenting on specific posts, Facebook builds a profile of that user based on who they are and what they're interested in.

This fact makes Facebook very attractive for advertisers. Advertisers can create Facebook adverts, then create an 'Audience' for that advert or group of adverts. Audiences can be built from a range of attributes including gender, age, location and interests. This specific targeting means advertisers can tailor content appropriately for a specific audience, even if the product being marketed is the same.

For example, let's imagine a company wants to advertise its new car. They may wish to promote one set of features, performance and the 2 kW stereo, to women in their early twenties. They might decide that they want to talk about it's fuel efficiency and reduced emissions to men in their thirties, and they might want to push the spacious interior and safety rating to men and women in their thirties and early forties who are interested in Families magazine and who like pages of nappy and baby clothes manufacturers.

In 2016, Facebook's revenue from advertising was **26bn, up from 17bn** the year before. This compares to Google's **79bn, the **638m that Twitter advertising made in Q4 2016, and $173m that LinkedIn made from ads in Q3 2016. These figures illustrate just how big an advertising platform is, although it faces challenges for the future with a decline in younger users in 2017, with generation Z moving to Snapchat and Instagram. When it comes to analyzing the Facebook adverts dataset, there are a lot of questions we can ask, and a lot of insight we can generate. However, from a business perspective we want to ask questions that will give us answers we can use to improve business performance. 

&nbsp;
&nbsp;


### 2. Case study (Business Understanding Phase)

The company xyz is an e-marketing company. It earns money based on how many people click the ads and how many people actually purchase the product advertised. The company will receive from the manufacturer **5 for each user that clicks on ad and signs up in the e-commerce shop, and respectively, **100 for each registered user that buys the product. On the other hand, the xyz pays to Facebook to display the ads. The objective of the company xyz is to maximize the return on advertising spent, while minimizing the amount spent on advertising. In order to attain this objective, the company needs to identify the factors (e.g. spending, campaign type, customer type, etc.) influencing most significantly the return on advertising spent (ROAS) based on the available data. 

The analytical objective in this case is to predict the Return on Advertising Spent (ROAS) using the dataset KAG_conversion_data.csv. Given the scope of this case study, we aim to set up a non-linear regression model. The model can be used either to predict the value of the target variable, ROAS, for future observations of the explanatory variables or to provide a better understanding of the relationships (form and direction) between dependent and independent variables. 

&nbsp;
&nbsp;


### 3. The data (Data Understanding Phase)

The documentation describes the columns in the data as follows:

1. ad_id: unique ID for each ad. It is just an identifier.
2. xyz_campaign_id: an ID associated with each ad campaign of XYZ company
3. fb_campaign_id: an ID associated with how Facebook tracks each campaign. Ignore this variable in the analysis
4. age: age of the person to whom the ad is shown
5. gender: gender of the person to whom the add is shown
6. interest: a code specifying the category to which the persons interest belongs (interests are as mentioned in the persons Facebook public profile)
7. Impressions: the number of times the ad was shown
8. Clicks: number of clicks on for that ad
9. Spent: Amount paid by company xyz to Facebook, to show that ad
10. Total conversion: Total number of people who sign up to the webshop after seeing the ad (here we (the add company) receives 5$)
11. Approved conversion/leads: Total number of people who bought the product after seeing the ad (here we (the add company) receives 10$)

**We want to predict ROAS, that is return on advertising spending**

&nbsp;
&nbsp;



### 4. Specific requirements: 

&nbsp;
&nbsp;

#### 4.1 Task 1 - Import and overview

Import and view the data. A critical step in the data mining process is to understand the variables, and further to ensure that the software interprets the variables in the correct way. 

```{r}
KAG_conversion_data <- read.csv("Data/1. MovingBeyondLinearity/FacebookCasestudy/KAG_conversion_data.csv")
```

&nbsp;
&nbsp;

#### 4.2 Task 2 - Data inspection

Inspect your data and do the required variable adaptations and transformations. These may include: treating the missing data, treating the outliers, log transformations, binning, standardizing, and creating additional features (e.g. in this particular case, one needs to calculate the DV (ROAS), which is not ready available in the dataset).

**NOTICE for the exam, we will not be asked to transform the data. Or at least the will specify what to do**

In real practice, data preprocessing takes about 75% of the total time assigned to a project.

```{r}
library(tidyverse)
dataTf <- KAG_conversion_data
glimpse(KAG_conversion_data) #Just a quick inspection
```

Renaming variables

*In general it is a good idea not to have special charactors in the variable name.*

```{r}
dataTf <- dataTf %>% 
  rename(xyzCampId = xyz_campaign_id, fbCampId = fb_campaign_id, impr = Impressions,
         conv = Total_Conversion, appConv = Approved_Conversion)
```

Create new features and calculate ROAS 

*Notice, that we use `mutate()` to make the new variables*

- Click-through-rate: how many of the impressions became clicks.CTR = Clicks/Impressions
- Cost Per Click: how much on average did each click cost.CPC = Spent/Clicks

```{r}
library(dplyr)
dataTf <- dataTf %>%  
  mutate(CTR = ((Clicks / impr) * 100), CPC = Spent / Clicks) 
dataTf$CTR <- round(dataTf$CTR, 4) #NB: Sometime rounding is necessary for packages to work
dataTf$CPC <- round(dataTf$CPC, 2)
```

Now we can also make the following variables:

- Conversion value: conval = 5 *  conv
- Approved conversion value: appConVal = 100 * appConv
- Total conversion: totConVal = conval + appConVal 
- Cost per conversion: costPerCon = Spent/totConv
- Return on Advertising Spend (the revenue as a % of advertising spend) : ROAS = totConVal/Spent
- Cost Per Mille: the cost of one thousand impressions. If our objective is ad exposure to increase brand awareness,this might be an important to measure. CPM = Spent/Impr *1000. I.e. how much of the overall spenditure divided by the amount of impressions. We multiply with 1000, to have more readable numbers instead of decimals.


```{r}
dataTf <- dataTf %>%
  mutate(totConv = conv + appConv,
         conVal = conv * 5,
         appConVal = appConv * 100) %>%
  mutate(totConVal = conVal + appConVal) %>%
  mutate(costPerCon = round(Spent / totConv, 2),
         ROAS = round(totConVal / Spent, 2))
dataTf <- dataTf %>%
  mutate(CPM = round((Spent / impr) * 1000, 2)) #Cost per Mille.
```

We see that this produce a lot of INF, that is because some of the underlying varaibles contain NaNs, which is regarded as non available values, hence we cant do math with it. These observations will be identified in the following.

Hence: Dealing with missing, currupt and invalid data

```{r}
# Decide between missing values imputation or deletion 
table(is.na(dataTf)) 
summary(dataTf) 
library(DataExplorer) 
plot_missing(dataTf)
```

**Genereal rule of thumb, if we have less than 5%, we can exclude them, if more than 5%, then we should impute values, so we preserve the dataset. One must make aware of this**

We just choose to ommit despite missing 18% in CPC

```{r}
dataTfo = na.omit(dataTf) #Df with the NA's omitted

# Dividing by zero create Inf values
dataTfo$costPerCon <- ifelse(dataTfo$costPerCon == Inf, 0, dataTfo$costPerCon) 
summary(dataTfo$costPerCon)
```


```{r}
# Re-check the correctness of data type and adapt
dataTfo$xyzCampId=as.factor(dataTfo$xyzCampId)
dataTfo$age=as.factor(dataTfo$age)
dataTfo$gender=as.factor(dataTfo$gender)
dataTfo$interest=as.factor(dataTfo$interest) # too many (non-representative) categories?

dataTfo$appConv= as.numeric(dataTfo$appConv)
dataTfo$conv= as.numeric(dataTfo$conv)
dataTfo$impr= as.numeric(dataTfo$impr)
dataTfo$Clicks= as.numeric(dataTfo$Clicks)
dataTfo$totConv= as.numeric(dataTfo$totConv)

str(dataTfo)
```


```{r}
# Check distribution of variables (univariate analysis) 
library(DataExplorer) 
options(repr.plot.width=4, repr.plot.height=4)
plot_bar(dataTfo) #This is a really good tool to plot all bars
```

We can also check all of the distributions.

```{r}
plot_histogram(dataTfo)
```

Now we can treat outliers.

```{r}
# Treat outliers
attach(dataTfo)
  # e.g. for ROAS
  boxplot(ROAS)
```

We want to see the boxplot being like a plot.

We observe that some of the observations are outside of the whiskers, these appear to be outliers. We can identify these with the $out command, see the following.

```{r}
boxplot(ROAS)$out
```

We see that all of these above are outliers.

```{r}
# Here I assign outliers to a vector and remove them
  outliers <- boxplot(ROAS
                      ,plot=FALSE)$out #PLOT = TRUE will plot the boxplot

  # remove the rows containing the outliers
  dataTfo1 <- dataTfo[-which(ROAS %in% outliers),] 
  boxplot(dataTfo1$ROAS)
  # Alterative ways to treat outliers exist 
```

Naturally there are other ways of identifying outliers, this is just one approach.

Looking at the new boxplot, we see that most observations are within the whiskers (the lines).

*Notice, it does not have to be errors in the data and thus it does not necessarily be non representing of the data, thus one may not want to delete them*


```{r}
# Check bivariate distributions or measures of association 
# pairs(data) # only numeric
# or one by one
ggplot(dataTfo1, aes(x=xyzCampId, y=ROAS)) + stat_summary(fun.y="mean", geom="bar")
```


```{r}
ggplot(dataTfo1, aes(x=age, y=ROAS)) + stat_summary(fun.y="mean", geom="bar")
```


```{r}
ggplot(dataTfo1, aes(x=gender, y=ROAS)) + stat_summary(fun.y="mean", geom="bar")
```


```{r}
ggplot(dataTfo1, aes(x=interest, y=ROAS)) + stat_summary(fun.y="mean", geom="bar")
```


```{r}
ggplot(dataTfo1, aes(Spent, ROAS)) + geom_point() + labs(x = "Amount spent on campaign", y = "ROAS")
```

```{r}
options(repr.plot.width=6, repr.plot.height=3)
ggplot(dataTfo1, aes(Spent, totConv)) + geom_point() + labs(x = "Amount spent on campaign", y = "Total Conversions")
```

```{r}
# Measure of associations 
par(mfrow = c(1, 1))
library(corrplot)
cormatrix = corrplot(cor(dataTfo1 [, -c(1:6)]))
```

We seee that some variables appear to have a strong correlation with other variables, e.g. CTR and CPM.

We want to see how they interact with ROAS as well, to get an idea of wether they are positive and negative relationship.

***NOTICE, this is based on a linear relationship between the variables. Since we are now in non linear models, we cannot use it the same way as when working in the linear scenarios. But we must be aware of variables that appear to have a really high correlation with one and other, hence we may exclude these.***

The following is the same, but presented just with actual correlations.

```{r}
cor(dataTfo1[,-c(1:6)],dataTfo1$ROAS)
```

&nbsp;
&nbsp;

Other exploration techniques can be implemented. Data pre-processing remains an active area of research because of the huge amount of inconsistent or "dirty" data.

&nbsp;
&nbsp;



#### 4.3 Task 3 - Building different models

Build several predictive models and evaluate their performance. First, consider reflecting about these specific questions:

  Q1) Which of the so far introduced models can be applied to explain and predict the return on advertising spent (ROAS)? Later on, construct several models that answer to this question, using a training dataset. 
  
  Q2) Which sample should one use to evaluate the model? Furthermore, which model assessment and selection criteria applies in this case? Later on, evaluate the model based on applicable assessment and selection criteria.
  
  Q3) Reflect about how one can improve the model prediction power.


```{r}
# Splitting the data
library(ISLR)
smp_size <- floor(0.75 * nrow(dataTfo1))
set.seed(123)
train_ind <- sample(seq_len(nrow(dataTfo1)), size = smp_size)
trainTfo1 <- dataTfo1[train_ind, ]
testTfo1 <- dataTfo1[-train_ind, ]
```

&nbsp;
&nbsp;

##### A Generalized Additive Model (GAM) to predict ROAS

The questions that arise are: 

  i) What subset of all the predictors can best explain and predict ROAS?
  ii) What is the form of the relationships between them and ROAS? 

&nbsp;
&nbsp;


Feature selection approaches include: 

 a) Generally looking at the variables "one by one", to understand what features are important and to figure out how they contribute towards solving the problem.

 b) Looking at the correlation matrix:  If we are working with a model which assumes a linear relationship between the dependent and the independent variables, corr matrix can help us come up with an initial list of variable importance. However, corr matrix also works as a "rough informative tool" for nonlinear modelling. 

 c) Running automatic feature selection algorithms. Functions in R include, among others: 

     - c1. regsubsets() function in "leaps" library (presented in ISL, p. 244); used to select the best size model that contains a given number of predictors, where best is quantified using Residual Sum of Squares (RSS). Although regsubsets() is based on testing linear models, it works as a "rough" list for nonlinear models.
     - c2. step.Gam() function in "gam" library for stepwise selection of variables in GAM models. This is useful when the number of predictors is not very high.
     - c3. advanced feature selection methods based on other data-mining techniques, including but not only: random forests, Bayesian Networks, Neural Networks, or other. Notice, that we can use very complex methods of feature selection, and then construct a model that is more transparant, for instance GAMs


###### c1) Feature selection using regsubsets()

One may exclude ad_id and variables used to calculate our dependent variable ROAS, as they have a deterministic relation with it. The variable "interests" can be preprocessed to reduce the categories to the most representative ones, but for simplicity we keep it as it is. See later it creates some problems.

```{r}
str(trainTfo1)
```

Now we can make the selection with forward selection.

```{r}
library(leaps) 
reg.fit = regsubsets(trainTfo1$ROAS ~ ., data = trainTfo1[,-c(1,3, 14:17)], method = "forward", nvmax=14)
reg.summary = summary(reg.fit)
reg.summary
```

Recall, an asteriks indicates that a given variable is included in the corresponding model. The default is "1 subsets of each size up to 8", but using "nvmax" option we can control as many variables as are desired.

Use a prediction error criteria (Adj^R2 BIC, Cp) to select the "best overall" model: names(reg.summary)

In this example $R^2$ is applied.

```{r}
reg.summary$rsq
```

Rsquare increases monotonically as more variables are included. This is expected; the model containing all predictors will always have the smallest RSS and the largest $R^2$. 

```{r}
plot(reg.summary$adjr2, xlab = "Number of Variables", ylab = "Adjusted R2", type = "p", ylim = c(0.1, 1), main = " Adj R2 for each model")
grid(col = "darkgrey")
max.adjr2 = max(reg.summary$adjr2)
std.adjr2 = sd(reg.summary$adjr2)
abline(h = max.adjr2 + 0.2 * std.adjr2, col = "red", lty = 2)
abline(h = max.adjr2 - 0.2 * std.adjr2, col = "red", lty = 2)
```

The plot shows the size 10-11 is the minimum size for the subset for which the scores are within 0.2 standard deviations of optimum. 

That is because the $R^2$ does not significantly change. Therefore, we can just limit ourselves with a more simple model.

**We can see how the selection changes if we use the full model**

*A common approach when dataset is small is to find best 10 variables using entire dataset.*

Notice, that some researches will argue that this implies data leakage.

```{r}
reg.fit = regsubsets(dataTfo1$ROAS ~ ., data = dataTfo1[,-c(1,3, 14:17)], method = "forward", nvmax=14)
summary(reg.fit)
```

We want to select 10 variables.

```{r}
coefi = coef(reg.fit
             , id=10) #Selection 10 variables
names(coefi) # most important variables based on regsubsets() feature selection
```


####### 1) I run a linear regression using the selected features, to have a benchmark 

In general, one should start with a simple model to see graudally advance, instead of jumping directly to complex models.

```{r}
model1<-lm(ROAS ~  interest + impr + conv + appConv + CTR + costPerCon + CPM, data = trainTfo1)
summary(model1) # summary.aov(model1) #Alternatice
```


```{r}
AIC(model1)
```

The model diagnostics

```{r}
par(mfrow = c(2, 2))
plot(model1)
```

Notice, that the top right is the theoretical distribution (or quantiles) of a normal distribution. We see that the is a wave in the residuals, implying that there may be some non linearity.


Further inspecting the residuals

```{r}
par(mfrow = c(1,1))
hist(model1$residuals)
```

The residuals look quite well


####### 2) Linked to the topic of this lecture, run a non-liner model, such as the Generalized Additive Model (GAM) with smoothing splines.**

We have two available approaches at hand:

1. Option 1: using  "gam" function from "gam" package
2. Option 2: using  "gam" function from "mgcv" package

+ Recall mgcv package and gam package may interact. Uncall one of them if you get an error.   

```{r}
library('mgcv')
set.seed(123)
gam.mgcv <- mgcv::gam(ROAS ~ interest + s(impr) + s(conv) + s(appConv) + s(CTR) + s(costPerCon) + s(CPM), data = trainTfo1) # "gam" function from "mgcv" package estimates the smoothness automatically based on cross-validation (LOOCV, the default) or REML (Restricted Maximum Likelihood)
summary(gam.mgcv)
```

We see from the **approximate significance of the smooth terms**, that the smoothed variables appear to be siginificant, hence the smoothing splines are justified. We can also see the edf (estimated degrees of freedom), for each of the variables.

The first ***parametric coefficients*** show how the varibles perform compared to the reference (baseline), we see that there are different p-values, where it looks as if interest 36 is the only significant, although we must remember that this is in reference to the baseline, hence it does not imply that the categories with p > 5% is insignificant. If we look further into the variable, we see that some of the categories have very few variables, hence we can bin the categories together. E.g.,

```{r}
table(trainTfo1$interest)
```

E.g. interest 114 have only four obsevationbs, we can aggregate groups, e.g., by looking at the means of the groups.

```{r}
aggregate(trainTfo1$ROAS,by = list(trainTfo1$interest),mean)
```

We see that they are close to each other, where one could combine groups based on this.


\

For which variables, if any, is there evidence of a non-linear relationship with the response? in the output, the edf (estimated degrees of freedom) column allow us to interpret the degree of nonlinearity for each predictor.

```{r}
# contrasts(trainTfo1$interest)

AIC(gam.mgcv) # decreases compared to linear model
```

***Other checks***

**One should always check the residuals**

```{r}
par(mfrow = c(1,1))
plot(gam.mgcv$residuals)
qqnorm(gam.mgcv$residuals)
qqline(gam.mgcv$residuals)
hist((gam.mgcv$residuals))
```

interpreting the partial effects of the smooth terms visually using plot(gam_model) (see p. 284 ISL).

```{r}
par(mfrow = c(2, 2))
plot(gam.mgcv, se = T, col = "blue", scheme=1,unconditional = TRUE, residuals = TRUE) 
```

Holding all the other variables in the model fixed, return on advertising spent tends to decrease with increasing impr (the number of times the ad was shown). holding all the other variables in the model fixed, total people signing up to the webshop (conv) has no significant effect on ROAS. Holding all the other variables in the model fixed, total people purchasing the product (appConv) and click-through-rate (CTR) have a significant positive nonlinear effect on ROAS. However, the CI in some areas is also very large due to very few observations, thus more data is required to evaluate the results. Finally cost-per-click (CPM = Spent/Impr *1000) has a decreasing nonlinear effect on ROAS, but the effect is very uncertain given CI become very large when CPM >1. Overall, the relationships found are intuitive but the effec ts are not strong. 



```{r}
# Evaluating test MSE using using k-fold cross-validation
set.seed(1)
k=5
folds = sample(1:k, nrow(trainTfo1), replace = TRUE)
gam.err = matrix(NA, k)
gam.tss = matrix(NA, k)
cv.r2 = matrix(NA, k)

for (j in 1:k) {
  gam.mgcv = mgcv::gam(ROAS ~ s(impr) + s(conv) + s(appConv) + s(CTR) + s(costPerCon) + s(CPM), data = trainTfo1[folds!=j,])  # folds !=j returns the in-sample data
  pred = predict(gam.mgcv, trainTfo1[folds==j,])
  gam.err[j] = mean((trainTfo1$ROAS[folds==j] - pred)^2) 
  gam.tss[j] = mean((trainTfo1$ROAS[folds==j] - mean(trainTfo1$ROAS[folds==j]))^2) 
  cv.r2[j] = 1 - gam.err[j]/gam.tss[j] 
  cv.r2[j] 
}

cv.r2
```

We see the different R squares, this we are now going to take the mean of.

```{r}
mean.cv.R2=apply (cv.r2, 2, mean)
mean.cv.R2
```

The mean is 0.697. Now we can compare the model with the test partition.


***Evaluating the model test MSE and R^2 using the test dataset***

```{r}
gam.pred = predict(gam.mgcv, testTfo1)
gam.err = mean((testTfo1$ROAS - gam.pred)^2) 
gam.tss = mean((testTfo1$ROAS - mean(testTfo1$ROAS))^2) 
test.r2 = 1 - gam.err/gam.tss 
test.r2 # the % of explained variance (R^2 in the data test)
```

We see that R2 is similar, hence the model does not appear to have high optimisim.

***Accuracy***

Accuracy: correlation Actual vs. Predicted values

```{r}
actuals_preds <- data.frame(cbind(actuals=testTfo1$ROAS,predicteds=gam.pred))  
correlation_accuracy <- cor(actuals_preds)  
correlation_accuracy
```

&nbsp;
&nbsp;

General discussion: Although the fitted GAM yields to a decent R^2 on the test set and cross-validation, it could further be evaluated in comparison with the fit of other models. It is also possible to improve the model by including additional variables. Product advertised or Price may improve the model fit. It is important to consider all possible input variables and make a good selection early in the analytical process.    

&nbsp;
&nbsp;


###### c2) Feature selection using step.GAM

Notice, that this is just another approach.

in package gam, the analysist has to search for the effective df. One can create a scope list with possible splines for each continous variable. Below, we considered splines up to maximum 5 degrees of freedom.


```{r}
library(gam)

#Making a list with the different models
scope_list = list("xyzCampId" = ~1 + xyzCampId,
                  "age" = ~1 + age,
                  "gender" = ~1 + gender,
                  "interest" = ~1 + interest,
                  "impr" = ~1 + impr + s(impr, df=2) + s(impr, df=3) + s(impr, df =4) + s(impr, df=5),
                  "Clicks" = ~1+Clicks+s(Clicks, df=2)+s(Clicks, df=3)+s(Clicks, df=4)+s(Clicks, df=5),
                  "Spent" = ~1 + Spent + s(Spent, df=2) + s(Spent, df=3) + s(Spent, df=4) + s(Spent, df=5),
                  "conv" = ~1 + conv + s(conv, df=2) + s(conv, df=3) + s(conv, df=4) + s(conv, df=5),
                  "appConv" = ~1+appConv+s(appConv,df=2)+s(appConv,df=3)+s(appConv,df=4)+s(appConv,df=5),
                  "CTR" = ~1 + CTR + s(CTR, df=2) + s(CTR, df=3) + s(CTR, df=4) + s(CTR, df=5),
                  "CPC" = ~1 + CPC + s(CPC, df=2) + s(CPC, df=3) + s(CPC, df=4) + s(CPC, df=5),
                  "CPM" = ~1 + CPM + s(CPM, df=2) + s(CPM, df=3) + s(CPM, df=4) + s(CPM, df=5))

# Define the starting model
gam.start <- gam::gam(ROAS ~ xyzCampId + age + gender + interest + impr + Clicks + Spent + conv + appConv + CTR + CPC + CPM, data = trainTfo1) 

# Finally, search among different models
# Remove "tick / check mark" from the package mgcv if you get an error next
gam::step.Gam(gam.start,scope = scope_list)
```

The last model is the best model, hence

gam::gam(formula = ROAS ~ impr + s(Clicks, df = 5) + s(appConv,df = 5) + s(CTR, df = 3) + s(CPC, df = 4) + CPM, data = trainTfo1,trace = FALSE)

+ AIC is used internally to pick the best model.
+ This is reported in the function output at every step.
+ The best model meaning it has the lowest AIC in the space it has searched.
+ In this case, the best model was:
+ ROAS ~ impr + s(Clicks, df = 5) + s(appConv,df = 5) + s(CTR, df = 3) + s(CPC, df = 4) + CPM.


**Next, run the recommended model and evaluate the AIC. Is it better than the previous ones?**

```{r}
library(gam)

#The model found in gam.step()
gam.step <- gam::gam(ROAS ~  impr + s(Clicks, df = 5) + s(appConv,df = 5) + s(CTR, df = 3) + s(CPC, df = 4) + CPM, data = trainTfo1)

summary(gam.step)
```


```{r}
par(mfrow = c(2, 3))
plot(gam.step, se = T, col = "blue")
```


```{r}
AIC(gam.step)
```

Compare AIC values for all fitted models

```{r}
AIC(model1, gam.mgcv, gam.step) 
```

We see that the second approach appear to be better than the step model.

&nbsp;
&nbsp;

###### c3) Fetaure selection using random forest

Advanced feature selection methods is an active domain of research. Modern techniques include, among others, using random forests to find a set of predictors that best explains the variance in the response variable (Random forests models is covered in Ch.8). For a review of all methods, consider this suplementary readings: A. Jovi, K. Brki and N. Bogunovi "A review of feature selection methods with applications". 

Feature selection using Random Forest (RF) 

RF is covered in-depth in the next lectures 


```{r}
library(party)
cf1 <- cforest(trainTfo1$ROAS ~ . , data = trainTfo1[,-c(1, 3, 14:17)]
               ,control=cforest_unbiased(mtry=2,ntree=100))

#We sort the variables for where importance is decreasing
sort(varimp(cf1), decreasing = TRUE)  
```

Based on the estimated variable importance, select the most relevant ones. Different feature selection methods, yield to slighly different variables, but majority coincide. 

```{r}
library(mgcv)
gam.rforest <- mgcv::gam(ROAS ~ s(appConv) + s(costPerCon) + s(Spent) + s(Clicks) + s(impr) + s(conv) + s(CPM) + xyzCampId + s(CTR), data = trainTfo1)
summary(gam.rforest)
```

discuss sig.

```{r}
AIC(gam.rforest)
```

Compare AIC values for all fitted models

```{r}
AIC(model1, gam.mgcv, gam.step, gam.rforest) 
```

Evaluate the gam.rforest using k-fold cv-error, MSE and R^2 as done before with gam.mgcv.

Conclude about the best model.
